# 你不知道的 js 学习记录

- 变量命名是否具有语义化
- 避免过度封装（多余的复杂的组件嵌套） 维护性优先
- 尝试在没有数据的接口制造数据确保需求开发传参无误、数据展示的格式无误（例如日期时间格式化）、数据展示超出问题（例如数据长度造成元素溢出）
- 上传功能（文件类型是否正确、文件大小限制、文件数量限制、上传一个空的文件/文件夹，测试是否能够正常上传、上传失败后再进行上传操作，测试能够继续正常上传）
- 添加必要的 loading
- 弹窗表单关闭时数据重置问题
- 数据表格执行 增删改操作后 需要更新视图
- 数据表格单元格内容超出显示不全处理
- 必要时添加数据为空时的说明

## 使用代码示例

- 可以在这里下载本书第一部分“作用域和闭包”随附的资料（代码示例、练习题等）：http://bit.ly/1c8HEWF。

- 可以在这里下载本书第二部分“this 和对象原型”随附的资料（代码示例、练习题等）：http://bit.ly/ydkjs-this-code

## 网址

- 本书第一部分“作用域和闭包”的网址是 http://oreil.ly/JS_scope_

closures。

- 本书第二部分“this 和对象原型”的网址是 http://bit.ly/ydk-js-this-object-prototypes

## 作用域

- 变量存储在什么地方？程序运行时如何找到他？
-

### 编译原理

- js 是一门编译语言 `但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中进行移植`

- 传统语言编译流程

  - 分词/词法分析 -> 将代码分解成词法单元
  - 解析/语法分析 -> 将词法单元流转换成一个由元素逐级嵌套所组成了代表程序语法结构的树，这个树称之为`AST抽象语法树`
  - 代码生成 -> 将 AST 转换为可执行的代码的过程称之为代码生成

- JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等

## 程序运行三部件

- 引擎

  - 从头到尾负责整个 JavaScript 程序的编译及执行过程。

- 编译器

  - 引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

- 作用域

  - 引擎的另一位好朋友，负责收集并维护由所有`声明的标识符（变量）`组成的一系列查

    询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的`访问权限`。

## 词法作用域

- 词法作用域就是定义在词法阶段的作用域。换句话说，`词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的`
- RHS 引用查询
- LHS

### 欺骗词法（降低性能）

- eval 直接将代码用字符串传入 将字符串中的代码视为书写的
- with

## 函数作用域和块作用域

- try catch 是块作用域
- let

- 变量提升
- 函数提升 函数优先

## 闭包

- javascript 中闭包无处不在，你只需要能够识别并拥抱它

- b 函数拥有 a 函数内部作用域的闭包，使得 a 函数里的作用域能够一直存活，供 b 函数在任何时候进行引用 b 函数对 a 函数作用域的引用 叫做 `闭包`

- 本质上无论何时何地，如果将函数（访问她们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。

- 使用回调函数 实际上就是在使用闭包

- 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时

  就产生了闭包

## 循环和闭包

```JS
for (var i=1; i<=5; i++) {
    (function() {
        setTimeout( function timer() {
            console.log( i );
        }, i*1000 );
    })();
}
```

- 输出 5 次 6 的原因是 同一个作用域当中共享一个 i 的引用

```JS
for (var i=1; i<=5; i++) {
    (function() {
		var j = i;
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })();
}
```

- 将 i 的值在各自的作用域里面储存起来 就能输出 1，2，3，4，5 了

```JS
// 优化
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })( i );
}
```

- 重返块作用域 -> let

```JS
for (LET i=1; i<=5; i++) {
    setTimeout( function timer() {
        console.log( j );
    }, j*1000 );
}
```

## this

- 特别的关键字，被自动定义在所有函数的作用域中

- this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用

- new 关键字可以影响 this 关键字的绑定

## 对象

- 深拷贝 ` var newObj = JSON.parse(JSON.stringify(someobj))` 目的是为了保证 JSON 对象是安全的

- 浅拷贝` Object.assign({},myObject)`

- `defineProperty`

  - 用于创建或者修改对象的一个属性
  - 把 `configurable` 修改成 false 是单向操作，无法再修改为 true 并且该状态下的属性无法删除

  - 如果`enunerable` 为`false` 的时候`for in` 循环也不会循环出来
    - 可枚举 就相当于 可以出现在对象属性的遍历中
  - `writable：false` 和 `configurable：false` 就可以创建一个真正的常量属性 （不可修改、重定义或者删除）

- `Object.preventExtensions()` 方法可以禁止一个对象添加新属性并且保留已有属性

- `Object.freeze()`会创建一个冻结对象
  - 深度冻结 遍历对象的属性 将属性为对象的全部用`Object.freeze()`调用

## 类

- `javaScript` 不存在真正的类 类还是通过 prototype 机制实现的

- 多态
  - car 重写了继承自父类的 drive()方法，但是之后 Car 调用了 inherited：drive()方法，这表明 Car 可以引用继承来的原始 drive()方法 这个技术被称为多态
- 混入

```js
function mixin(sourceObj, targetObj) {
  for (var key in sourceObj) {
    // 只会在不存在的情况下复制
    if (!(key in targetObj)) {
      targetObj[key] = sourceObj[key];
    }
  }
  return targetObj;
}
```

- 屏蔽机制

## 原型

- 函数‘类’ es6 之前为了模仿类的功能 为了继承
- prototype 机制就是存在于对象中的一个内部链接引用另一个对象
  - 这个链接的作用就是在这个对象上没有找到需要的属性，引擎就会继续在 prototype 关联的对象上去寻找这个属性，若还是没有找到则会重复这个操作 直到找到 Object 这一系列对象的链接称之为`原型链`

## 对象关联

- `Object.create()`

```js
// es5之前 Object.create() 的实现
if (!Object.create) {
  Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
  };
}
```

- 看起来对象之间的关联关系是才处理”缺失“属性或者方法时的一种备用选项。但是这并不是 prototype 的本质

## 行为委托

- 禁止相互委托
-
